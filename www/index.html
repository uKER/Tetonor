<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetonor</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=DM+Mono:wght@400;500&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0f0e11;
    --surface: #1a1820;
    --surface2: #231f2e;
    --border: #2e2a3a;
    --accent: #c8a96e;
    --accent2: #7c6af7;
    --text: #e8e4f0;
    --muted: #6b6480;
    --green: #5dba89;
    --red: #e06b6b;
    --yellow: #e0b96b;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background-image: radial-gradient(ellipse at 20% 0%, rgba(124,106,247,0.07) 0%, transparent 60%),
                      radial-gradient(ellipse at 80% 100%, rgba(200,169,110,0.05) 0%, transparent 50%);
  }

  header {
    width: 100%;
    max-width: 700px;
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border);
  }

  h1 {
    font-family: 'DM Serif Display', serif;
    font-size: clamp(2rem, 5vw, 3rem);
    color: var(--accent);
    letter-spacing: -0.02em;
  }

  .subtitle {
    font-size: 0.75rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.12em;
    font-weight: 500;
  }
  header { position: relative; }
  .how-to-link {
    margin-left: auto;
    font-size: 0.75rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    font-weight: 500;
    cursor: pointer;
    user-select: none;
  }
  .how-to-link:hover { color: var(--text); }
  .how-to-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 200;
    align-items: center;
    justify-content: center;
  }
  .how-to-modal.show { display: flex; }
  .how-to-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 42px 48px;
    max-width: 570px;
    width: 90%;
    font-size: 1.275rem;
    color: var(--muted);
    line-height: 1.8;
  }
  .how-to-box strong { color: var(--text); }
  .how-to-title {
    font-family: 'DM Serif Display', serif;
    font-size: 2.1rem;
    color: var(--accent);
    margin-bottom: 14px;
  }

  .controls-row {
    width: 100%;
    max-width: 700px;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 24px;
  }

  .new-puzzle-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    user-select: none;
    line-height: 1;
    padding: 0 16px;
    height: 36px;
  }

  .new-puzzle-btn span {
    line-height: 1;
  }

  .diff-dropdown {
    position: relative;
  }

  .diff-current {
    color: var(--accent);
    cursor: pointer;
    font-size: 0.85rem;
    white-space: nowrap;
  }

  .diff-menu {
    display: none;
    position: absolute;
    top: calc(100% + 6px);
    left: 0;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    z-index: 50;
    min-width: 100px;
  }

  .diff-menu div {
    padding: 8px 14px;
    font-size: 0.85rem;
    color: var(--text);
    cursor: pointer;
    transition: background 0.1s;
  }

  .diff-menu div:hover { background: var(--border); color: var(--accent); }

  .diff-menu.open { display: block; }

  .btn {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text);
    padding: 0 16px;
    height: 36px;
    border-radius: 6px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.15s;
    font-weight: 400;
    display: flex;
    align-items: center;
  }
  .btn:hover { border-color: var(--accent2); color: var(--accent2); }
  .btn:disabled { opacity: 0.35; cursor: not-allowed; pointer-events: none; }

  .assist-label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
    color: var(--muted);
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
  }
  .assist-label input { accent-color: var(--accent2); cursor: pointer; }

  .assist-tip-wrap {
    position: relative;
    display: inline-flex;
    align-items: center;
  }

  .assist-tip-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 1px solid var(--muted);
    color: var(--muted);
    font-size: 0.7rem;
    cursor: default;
    line-height: 1;
    flex-shrink: 0;
  }

  .assist-tip-box {
    display: none;
    position: absolute;
    bottom: calc(100% + 8px);
    right: 0;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    font-size: 0.78rem;
    color: var(--text);
    width: 220px;
    white-space: normal;
    word-wrap: break-word;
    line-height: 1.5;
    z-index: 100;
    pointer-events: none;
    box-sizing: border-box;
  }

  .assist-tip-wrap:hover .assist-tip-box { display: block; }

  .btn.primary { background: var(--accent2); border-color: var(--accent2); color: white; }
  .btn.primary:hover { opacity: 0.85; }

  /* Main layout */
  .game-area {
    width: 100%;
    max-width: 700px;
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  /* Grid */
  .grid-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 20px;
  }

  .grid-label {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    color: var(--muted);
    margin-bottom: 14px;
    font-weight: 500;
  }

  .grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
  }

  .cell {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 8px 0 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0;
    transition: border-color 0.15s;
    cursor: pointer;
    min-height: 110px;
    position: relative;
    overflow: hidden;
  }

  .cell:hover { border-color: var(--accent2); }
  .cell.selected { border-color: var(--accent2); background: rgba(124,106,247,0.08); }
  .cell.correct { border-color: var(--green); background: rgba(93,186,137,0.06); }
  .cell.wrong { border-color: var(--red); background: rgba(224,107,107,0.06); }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20%       { transform: translateX(-6px); }
    40%       { transform: translateX(6px); }
    60%       { transform: translateX(-4px); }
    80%       { transform: translateX(4px); }
  }
  .cell.shake { animation: shake 0.4s ease; }

  @keyframes hint-pulse {
    0%   { box-shadow: 0 0 0 0px rgba(200,169,110,0); }
    40%  { box-shadow: 0 0 0 5px rgba(200,169,110,0.55); }
    100% { box-shadow: 0 0 0 0px rgba(200,169,110,0); }
  }
  .cell.hint-pulse { animation: hint-pulse 0.45s ease-out 2; }

  .cell-target {
    font-family: 'DM Serif Display', serif;
    font-size: 2.7rem;
    color: var(--accent);
    line-height: 1;
    margin-bottom: auto;
    padding-bottom: 10px;
  }

  .cell-entry {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    width: calc(100% + 16px);
    margin-left: -8px;
    margin-right: -8px;
    margin-bottom: 0;
    margin-top: 0;
    border-top: 1px solid var(--border);
    overflow: hidden;
    border-radius: 0 0 9px 9px;
  }

  .cell-entry .sub-box {
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'DM Mono', monospace;
    font-size: 1rem;
    color: var(--muted);
  }

  .cell-entry .sub-box + .sub-box {
    border-left: 1px solid var(--border);
  }

  .cell-entry.filled .sub-box { color: var(--accent); }
  .cell-entry.filled .sub-box.sub-op { color: var(--accent2); }
  .cell-entry .sub-box.sub-op { font-size: 1.2rem; }

  /* Strip */
  .strip-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 20px;
  }

  .strip-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 14px;
  }

  .strip {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 8px;
  }

  .strip-num {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    height: 52px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'DM Mono', monospace;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
    user-select: none;
  }

  .strip-num:hover:not(.hidden-num):not(.used) { border-color: var(--accent2); color: var(--accent2); transform: translateY(-2px); }
  .strip-num.selected-strip { border-color: var(--accent2); background: rgba(124,106,247,0.15); color: var(--accent2); }
  .strip-num.used-once {
  border-color: var(--accent) !important;
  color: var(--accent) !important;
}
.strip-num.used { opacity: 0.35 !important; border-color: transparent !important; border-style: solid !important; color: var(--muted) !important; cursor: pointer; }
.strip-num.used:hover { opacity: 0.6 !important; }
  .strip-num.hidden-num {
    color: transparent;
    cursor: pointer;
  }
  .strip-num.hidden-num::after {
    content: '?';
    position: absolute;
    color: var(--text);
    font-family: 'DM Mono', monospace;
    font-size: 1rem;
    font-weight: 500;
  }
  .strip-num.hidden-revealed {
    color: var(--accent);
  }

  /* Hidden number input modal */
  .modal-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(15,14,17,0.7);
    backdrop-filter: blur(6px);
    z-index: 50;
    align-items: center;
    justify-content: center;
  }
  .modal-backdrop.show { display: flex; }
  .modal {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 28px 32px;
    min-width: 280px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .modal-title {
    font-family: 'DM Serif Display', serif;
    font-size: 1.3rem;
    color: var(--accent);
  }
  .modal-sub {
    font-size: 0.8rem;
    color: var(--muted);
    margin-top: -8px;
  }
  .modal-input {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 14px;
    font-family: 'DM Mono', monospace;
    font-size: 1.1rem;
    color: var(--text);
    width: 100%;
    outline: none;
    transition: border-color 0.15s;
    text-align: center;
  }
  .modal-input:focus { border-color: var(--accent2); }
  .modal-row { display: flex; gap: 8px; }
  .modal-hint {
    font-size: 0.75rem;
    color: var(--muted);
    font-style: italic;
  }

  /* Op selector */
  .op-selector {
    display: flex;
    gap: 8px;
    justify-content: center;
  }

  .op-btn {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--muted);
    width: 44px;
    height: 44px;
    border-radius: 8px;
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.15s;
    font-family: 'DM Mono', monospace;
    display: flex; align-items: center; justify-content: center;
  }
  .op-btn:hover { border-color: var(--accent2); color: var(--accent2); }


  /* Entry panel */
  .entry-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 14px 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .entry-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .entry-row .status-bar {
    flex: 1;
    height: 36px;
    font-size: 0.82rem;
  }

  .status-bar {
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    border-radius: 8px;
    font-weight: 500;
    transition: all 0.3s;
    letter-spacing: 0.02em;
  }
  .status-bar.success { background: rgba(93,186,137,0.12); color: var(--green); border: 1px solid rgba(93,186,137,0.25); }
  .status-bar.error { background: rgba(224,107,107,0.12); color: var(--red); border: 1px solid rgba(224,107,107,0.2); }
  .status-bar.info { background: rgba(124,106,247,0.1); color: var(--accent2); border: 1px solid rgba(124,106,247,0.2); }
  .status-bar.empty { border: 1px solid transparent; }

  /* Rules panel */
  .rules {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 16px 20px;
    font-size: 0.8rem;
    color: var(--muted);
    line-height: 1.7;
  }
  .rules strong { color: var(--text); }

  /* Win overlay */
  .win-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 100;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 20px;
  }
  .win-overlay.show { display: flex; }
  .win-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 40px 60px;
    text-align: center;
    max-width: 400px;
  }
  .win-title {
    font-family: 'DM Serif Display', serif;
    font-size: 2.5rem;
    color: var(--green);
    margin-bottom: 8px;
  }
  .win-sub { color: var(--muted); font-size: 0.9rem; margin-bottom: 24px; }

  .progress-count {
    font-size: 0.8rem;
    color: var(--muted);
    font-family: 'DM Mono', monospace;
    white-space: nowrap;
    flex-shrink: 0;
  }

  @media (max-width: 500px) {
    body { padding: 12px; }
    .grid-container { padding: 12px; }
    .strip { grid-template-columns: repeat(8, 1fr); }
    .grid { gap: 6px; }
    .cell { min-height: 0; padding: 6px 6px 0 6px; }
    .cell-target { font-size: 1.8rem; padding-bottom: 6px; }
    .cell-entry .sub-box { height: 28px; }
  }

  .small-print {
    margin-top: 8px;
    margin-bottom: 12px;
    font-size: 0.7rem;
    color: var(--muted);
    text-align: center;
    opacity: 0.6;
  }
  .small-print a {
    color: inherit;
    text-decoration: underline;
    cursor: pointer;
  }

  .privacy-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 42px 48px;
    max-width: 570px;
    width: 90%;
    font-size: 1rem;
    color: var(--muted);
    line-height: 1.8;
  }
  .privacy-box strong { color: var(--text); }
  .privacy-box p { margin-bottom: 12px; }
  .privacy-box p:last-child { margin-bottom: 0; }
  .privacy-title {
    font-family: 'DM Serif Display', serif;
    font-size: 2.1rem;
    color: var(--accent);
    margin-bottom: 14px;
  }
</style>
</head>
<body>

<header>
  <div>
    <h1>Tetonor</h1>
    <span class="subtitle">Number Logic Puzzle</span>
  </div>
  <span class="how-to-link" onclick="document.getElementById('howToModal').classList.add('show')">How to play</span>
</header>

<!-- How to play modal -->
<div class="how-to-modal" id="howToModal" onclick="if(event.target===this)this.classList.remove('show')">
  <div class="how-to-box">
    <div class="how-to-title">How to play</div>
    Each target number in the grid is the <strong>sum or product</strong> of a pair from the bottom strip.
    Each pair must be used <strong>exactly twice</strong>: once as addition, once as multiplication.
    Click a grid cell to select it, pick two strip numbers and an operator (+/Ã—) â€” the entry confirms automatically.
    Hidden strip numbers (<strong>?</strong>) must be deduced â€” click them to enter your guess. They appear in ascending order.
  </div>
</div>

<div class="controls-row">
  <div class="new-puzzle-btn btn" id="newPuzzleBtn">
    <span onclick="generatePuzzle()">New Puzzle:</span>
    <div class="diff-dropdown" id="diffDropdown">
      <span class="diff-current" id="diffCurrent" onclick="toggleDiffMenu(event)">Easy â–¾</span>
      <div class="diff-menu" id="diffMenu">
        <div onclick="chooseDiff('easy','Easy',event)">Easy</div>
        <div onclick="chooseDiff('medium','Medium',event)">Medium</div>
        <div onclick="chooseDiff('hard','Hard',event)">Hard</div>
      </div>
    </div>
  </div>
  <label class="assist-label" style="margin-left:auto">
    <input type="checkbox" id="assistCheck" checked> Assist
    <span class="assist-tip-wrap">
      <span class="assist-tip-icon">?</span>
      <span class="assist-tip-box">When you pick a number that's already been used, Assist automatically fills in its partner with the unused operator.</span>
    </span>
  </label>
  <button class="btn" id="checkBtn" onclick="checkAll()">Check</button>
  <button class="btn primary" onclick="document.getElementById('revealModal').classList.add('show')">Reveal</button>
</div>

<div class="game-area">
  <!-- Grid -->
  <div class="grid-container">
    <div class="grid" id="grid"></div>
  </div>

  <!-- Strip + controls -->
  <div class="strip-container">
    <div class="strip" id="strip"></div>
    <div style="font-size:0.85rem;color:var(--muted);opacity:0.6;margin-top:6px;">Long press a guessed number to clear it</div>
    <div class="entry-row" style="margin-top:8px;">
      <button class="op-btn" id="opAdd" onclick="selectOp('+')">+</button>
      <button class="op-btn" id="opMul" onclick="selectOp('Ã—')">Ã—</button>
      <div class="status-bar empty" id="statusBar"></div>
      <span class="progress-count" id="progressCount">0 / 16</span>
      <button class="btn" id="clearBtn" onclick="clearEntry()">Clear</button>
    </div>
  </div>


</div>

<p class="small-print"><a onclick="document.getElementById('privacyModal').classList.add('show')">Privacy Policy</a></p>

<!-- New game confirmation modal -->
<div class="modal-backdrop" id="newGameModal">
  <div class="modal">
    <div class="modal-title">Start New Puzzle?</div>
    <div class="modal-sub">You have a puzzle in progress. Starting a new one will clear your progress.</div>
    <div class="modal-row">
      <button class="btn" onclick="closeNewGameModal()">Cancel</button>
      <button class="btn primary" onclick="confirmNewGame()">Start New</button>
    </div>
  </div>
</div>

<!-- Reveal confirmation modal -->
<div class="modal-backdrop" id="revealModal">
  <div class="modal">
    <div class="modal-title">Reveal Solution?</div>
    <div class="modal-sub">This will show all answers and end the puzzle.</div>
    <div class="modal-row">
      <button class="btn" onclick="document.getElementById('revealModal').classList.remove('show')">Cancel</button>
      <button class="btn primary" onclick="confirmReveal()">Reveal</button>
    </div>
  </div>
</div>

<!-- Hidden number modal -->
<div class="modal-backdrop" id="hiddenModal">
  <div class="modal">
    <div class="modal-title">Enter Hidden Number</div>
    <div class="modal-sub">What number do you think is hidden here?</div>
    <input class="modal-input" id="hiddenInput" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Your deduced valueâ€¦" oninput="this.value=this.value.replace(/[^0-9]/,'')">
    <div class="modal-row">
      <button class="btn" onclick="closeHiddenModal()">Cancel</button>
      <button class="btn primary" onclick="confirmHidden()">Confirm</button>
    </div>
  </div>
</div>

<!-- Privacy policy modal -->
<div class="how-to-modal" id="privacyModal" onclick="if(event.target===this)this.classList.remove('show')">
  <div class="privacy-box">
    <div class="privacy-title">Privacy Policy</div>
    <p>Tetonor does not collect, store, or share any personal data. The app has no user accounts, no analytics, no advertising, and no network communication of any kind.</p>
    <p><strong>Google Fonts.</strong> This app loads fonts from Google Fonts (fonts.googleapis.com). This request is made by your device directly to Google's servers and is subject to <strong><a href="https://policies.google.com/privacy" style="color:var(--accent2)">Google's Privacy Policy</a></strong>. No other third-party services are used.</p>
    <p>If you have any questions, contact: <strong>uKER@outlook.com</strong></p>
  </div>
</div>

<!-- Win overlay -->
<div class="win-overlay" id="winOverlay" onclick="if(event.target===this)this.classList.remove('show')">
  <div class="win-box">
    <div class="win-title">Solved!</div>
    <div class="win-sub" id="winSub">Excellent arithmetic deduction.</div>
    <button class="btn primary" style="display:block;margin:0 auto;" onclick="document.getElementById('winOverlay').classList.remove('show'); generatePuzzle()">Play Again</button>
  </div>
</div>

<script>
// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let difficulty = 'easy';
let puzzle = null;
let selectedCell = null;
let entryNums = [];
let entryOp = null;
let stripSelected = [];

// â”€â”€ Difficulty config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DIFF = {
  easy:   { min: 2,  max: 20, hidden: 5,  pairs: 8 },
  medium: { min: 5,  max: 35, hidden: 7,  pairs: 8 },
  hard:   { min: 10, max: 50, hidden: 11, pairs: 8 },
};

function setDifficulty(d) {
  difficulty = d;
  generatePuzzle();
}

function toggleDiffMenu(e) {
  e.stopPropagation();
  document.getElementById('diffMenu').classList.toggle('open');
}

let pendingDiff = null;
let statusTimeout = null;

function chooseDiff(val, label, e) {
  e.stopPropagation();
  document.getElementById('diffMenu').classList.remove('open');
  if (puzzle && puzzle.userEntries.some(e => e !== null)) {
    pendingDiff = { val, label };
    document.getElementById('newGameModal').classList.add('show');
  } else {
    difficulty = val;
    document.getElementById('diffCurrent').textContent = label + ' â–¾';
    generatePuzzle();
  }
}

function closeNewGameModal() {
  pendingDiff = null;
  document.getElementById('newGameModal').classList.remove('show');
}

function confirmNewGame() {
  document.getElementById('newGameModal').classList.remove('show');
  if (pendingDiff) {
    difficulty = pendingDiff.val;
    document.getElementById('diffCurrent').textContent = pendingDiff.label + ' â–¾';
    pendingDiff = null;
  }
  generatePuzzle();
}

document.addEventListener('click', e => {
  document.getElementById('diffMenu').classList.remove('open');
  if (selectedCell !== null
      && !e.target.closest('.cell, .strip-num, .op-btn, #clearBtn')
      && !e.target.closest('.modal-backdrop, .how-to-modal, .win-overlay')) {
    deselectCell();
  }
});

// â”€â”€ Puzzle generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generatePuzzle() {
  const cfg = DIFF[difficulty];
  let pairs = [];

  // Retry until we get exactly 8 pairs
  while (pairs.length < cfg.pairs) {
    pairs = [];
    const usedPairs = new Set();
    let attempts = 0;
    while (pairs.length < cfg.pairs && attempts < 10000) {
      attempts++;
      const a = randInt(cfg.min, Math.floor(cfg.max * 0.6));
      const b = randInt(cfg.min, cfg.max);
      if (a === b) continue;
      const sum = a + b;
      const prod = a * b;
      const key = `${Math.min(a,b)},${Math.max(a,b)}`;
      if (!usedPairs.has(key) && sum !== prod && sum <= 200 && prod <= 500) {
        usedPairs.add(key);
        pairs.push({ a, b, sum, prod });
      }
    }
  }

  // Build 4x4 grid: 16 cells, each pair contributes sum and prod â†’ 16 values
  const gridValues = [];
  for (const p of pairs) {
    gridValues.push({ value: p.sum, pair: p, op: '+' });
    gridValues.push({ value: p.prod, pair: p, op: 'Ã—' });
  }
  shuffle(gridValues);

  // Strip: all a's and b's sorted
  const stripNums = pairs.flatMap(p => [p.a, p.b]).sort((x,y) => x - y);

  // Choose hidden indices
  const hiddenSet = new Set();
  while (hiddenSet.size < cfg.hidden) {
    hiddenSet.add(randInt(0, stripNums.length - 1));
  }

  puzzle = {
    grid: gridValues,
    strip: stripNums,
    pairs,
    hidden: hiddenSet,
    userEntries: Array(16).fill(null),
    partialEntries: Array(16).fill(null),
  };

  clearState();
  renderGrid();
  renderStrip();
  updateProgress();
  setStatus('', '');
  document.getElementById('checkBtn').disabled = false;
  selectedCell = null;
  setTimeout(updateControlsState, 0);
}

function clearState() {
  selectedCell = null;
  entryNums = [];
  stripSelected = [];
  entryOp = null;
}

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = randInt(0, i);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderGrid() {
  const g = document.getElementById('grid');
  g.innerHTML = '';
  puzzle.grid.forEach((cell, i) => {
    const div = document.createElement('div');
    div.className = 'cell';
    div.dataset.idx = i;
    div.onclick = () => selectCell(i);

    const target = document.createElement('div');
    target.className = 'cell-target';
    target.textContent = cell.value;

    const entry = document.createElement('div');
    entry.className = 'cell-entry';
    entry.id = `cell-entry-${i}`;
    entry.innerHTML = `<span class="sub-box"></span><span class="sub-box sub-op"></span><span class="sub-box"></span>`;

    div.appendChild(target);
    div.appendChild(entry);
    g.appendChild(div);
    updateCellEntry(i);
  });
}

function updateCellEntry(i) {
  const entry = document.getElementById(`cell-entry-${i}`);
  if (!entry) return;
  const ue = puzzle.userEntries[i];
  if (ue) {
    entry.className = 'cell-entry filled';
    entry.innerHTML = `<span class="sub-box">${ue.a}</span><span class="sub-box sub-op">${ue.op}</span><span class="sub-box">${ue.b}</span>`;
    return;
  }
  const pe = puzzle.partialEntries[i];
  if (pe) {
    entry.className = 'cell-entry';
    entry.innerHTML = `<span class="sub-box">${pe.nums[0] ?? ''}</span><span class="sub-box sub-op">${pe.op ?? ''}</span><span class="sub-box">${pe.nums[1] ?? ''}</span>`;
    return;
  }
  entry.className = 'cell-entry';
  entry.innerHTML = `<span class="sub-box"></span><span class="sub-box sub-op"></span><span class="sub-box"></span>`;
}

function renderStrip() {
  const s = document.getElementById('strip');
  s.innerHTML = '';
  puzzle.strip.forEach((num, i) => {
    const div = document.createElement('div');
    div.className = 'strip-num' + (puzzle.hidden.has(i) ? ' hidden-num' : '');
    div.dataset.idx = i;
    div.dataset.val = num;
    div.textContent = puzzle.hidden.has(i) ? '' : num;
    if (puzzle.hidden.has(i)) {
      div.onclick = () => openHiddenModal(i);
    } else {
      div.onclick = () => pickStripNum(i, num);
    }
    s.appendChild(div);
  });
}

// â”€â”€ Interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function savePartialEntry(i) {
  if (i === null || !puzzle) return;
  if (entryNums.length > 0 || entryOp !== null) {
    puzzle.partialEntries[i] = { nums: [...entryNums], op: entryOp, stripSelected: [...stripSelected] };
  } else {
    puzzle.partialEntries[i] = null;
  }
}

function restorePartialEntry(i) {
  const pe = puzzle.partialEntries[i];
  if (pe) {
    entryNums = [...pe.nums];
    entryOp = pe.op;
    stripSelected = [...pe.stripSelected];
    stripSelected.forEach(si => {
      const el = document.querySelector(`.strip-num[data-idx="${si}"]`);
      if (el) el.classList.add('selected-strip');
    });
  }
}

function deselectCell() {
  if (selectedCell === null) return;
  savePartialEntry(selectedCell);
  updateCellEntry(selectedCell);
  document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
  entryNums = [];
  entryOp = null;
  stripSelected = [];
  document.querySelectorAll('.strip-num').forEach(s => s.classList.remove('selected-strip'));
  selectedCell = null;
  updateControlsState();
  setStatus('', '');
}

function selectCell(i, clearFilled = false) {
  if (selectedCell !== null && selectedCell !== i) {
    savePartialEntry(selectedCell);
    updateCellEntry(selectedCell);
  }
  document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
  entryNums = [];
  entryOp = null;
  stripSelected = [];
  document.querySelectorAll('.strip-num').forEach(s => s.classList.remove('selected-strip'));

  selectedCell = i;
  document.querySelector(`.cell[data-idx="${i}"]`).classList.add('selected');

  if (clearFilled && puzzle.userEntries[i] !== null) {
    puzzle.userEntries[i] = null;
    puzzle.partialEntries[i] = null;
    document.querySelector(`.cell[data-idx="${i}"]`).classList.remove('correct', 'wrong');
    renderStripState();
    updateProgress();
  } else if (puzzle.userEntries[i] === null) {
    restorePartialEntry(i);
  }

  updateCellEntry(i);
  updateControlsState();
  setStatus(`${puzzle.grid[i].value}`, 'info');
}

function pulseHintCells(si) {
  puzzle.userEntries.forEach((ue, ci) => {
    if (!ue || (ue.si1 !== si && ue.si2 !== si)) return;
    const cell = document.querySelector(`.cell[data-idx="${ci}"]`);
    if (!cell) return;
    cell.classList.remove('hint-pulse');
    void cell.offsetWidth; // restart animation if already running
    cell.classList.add('hint-pulse');
    cell.addEventListener('animationend', () => cell.classList.remove('hint-pulse'), { once: true });
  });
}

function pickStripNum(i, val) {
  if (selectedCell === null) {
    const used = puzzle.userEntries.some(ue => ue && (ue.si1 === i || ue.si2 === i));
    if (used) pulseHintCells(i);
    else setStatus('Select a grid cell first.', 'error');
    return;
  }
  if (entryNums.length >= 2) {
    setStatus('Already have two numbers. Clear to start over.', 'error');
    return;
  }
  // Block picking the same strip tile twice
  if (stripSelected.includes(i)) {
    setStatus('Pick a different strip number.', 'error');
    return;
  }
  stripSelected.push(i);
  entryNums.push(val);
  document.querySelector(`.strip-num[data-idx="${i}"]`).classList.add('selected-strip');
  const bar = document.getElementById('statusBar');
  if (bar.classList.contains('error')) setStatus(`${puzzle.grid[selectedCell].value}`, 'info');
  updateEntryDisplay();

  // Assist: if this is the first number and assist is on, look for a prior use of this value
  if (entryNums.length === 1 && document.getElementById('assistCheck').checked) {
    for (let ci = 0; ci < puzzle.userEntries.length; ci++) {
      const ue = puzzle.userEntries[ci];
      if (!ue) continue;
      if (ue.a === val || ue.b === val) {
        const partner = ue.a === val ? ue.b : ue.a;
        const oppositeOp = ue.op === '+' ? 'Ã—' : '+';
        entryOp = oppositeOp;
        updateEntryDisplay();
        const partnerIdx = puzzle.strip.findIndex((n, si) => n === partner &&
          !document.querySelector(`.strip-num[data-idx="${si}"]`).classList.contains('used') &&
          !stripSelected.includes(si));
        if (partnerIdx !== -1) {
          stripSelected.push(partnerIdx);
          entryNums.push(partner);
          document.querySelector(`.strip-num[data-idx="${partnerIdx}"]`).classList.add('selected-strip');
          updateEntryDisplay();
        }
        break;
      }
    }
  }

  updateControlsState();
}

function selectOp(op) {
  if (selectedCell === null) return;
  entryOp = op;
  const bar = document.getElementById('statusBar');
  if (bar.classList.contains('error')) setStatus('', '');
  updateEntryDisplay();
}

function updateControlsState() {
  const hasCell = selectedCell !== null;
  const cellFilled = hasCell && puzzle && puzzle.userEntries[selectedCell] !== null;
  const interactive = hasCell && !cellFilled;
  document.getElementById('opAdd').disabled = !interactive;
  document.getElementById('opMul').disabled = !interactive;
  document.getElementById('clearBtn').disabled = !(hasCell && (cellFilled || entryNums.length > 0));
  document.querySelectorAll('.strip-num').forEach(el => {
    if (el.classList.contains('used')) {
      // Fully used tiles: pulse onclick already set by updateStripState, no dimming
      return;
    }
    if (el.classList.contains('hidden-num') || el.classList.contains('hidden-revealed')) {
      // Hidden/revealed tiles: always clickable for guessing
      return;
    }
    const partial = el.classList.contains('used-once');
    if (partial) {
      // Partially used: allow navigation (no cell selected), block only when cell is filled
      el.style.pointerEvents = cellFilled ? 'none' : '';
      el.style.opacity = '';
    } else {
      // Unused: interactive only when a cell is selected and empty
      el.style.pointerEvents = interactive ? '' : 'none';
      el.style.opacity = interactive ? '' : '0.35';
    }
  });
}

function updateEntryDisplay() {
  if (selectedCell === null) return;
  const entry = document.getElementById(`cell-entry-${selectedCell}`);
  if (!entry) return;
  const boxes = entry.querySelectorAll('.sub-box');
  boxes[0].textContent = entryNums.length >= 1 ? entryNums[0] : '';
  boxes[1].textContent = entryOp !== null ? entryOp : '';
  boxes[2].textContent = entryNums.length >= 2 ? entryNums[1] : '';
  // Auto-confirm once all three are filled
  if (entryNums.length === 2 && entryOp !== null) {
    setTimeout(tryAutoConfirm, 120); // brief delay so player sees the filled state
  }
}

function clearEntry() {
  entryNums = [];
  stripSelected = [];
  entryOp = null;
  document.querySelectorAll('.strip-num').forEach(s => s.classList.remove('selected-strip'));
  if (selectedCell !== null) {
    puzzle.userEntries[selectedCell] = null;
    puzzle.partialEntries[selectedCell] = null;
    const cell = document.querySelector(`.cell[data-idx="${selectedCell}"]`);
    if (cell) cell.classList.remove('correct', 'wrong');
    updateCellEntry(selectedCell);
    // Re-enable any strip numbers whose pair is no longer complete
    renderStripState();
    updateProgress();
  }
  setStatus('', '');
}

function tryAutoConfirm() {
  if (selectedCell === null || entryNums.length < 2 || entryOp === null) return;

  const a = entryNums[0], b = entryNums[1];

  puzzle.userEntries[selectedCell] = { a, b, op: entryOp, si1: stripSelected[0], si2: stripSelected[1] };
  puzzle.partialEntries[selectedCell] = null;
  updateCellEntry(selectedCell);
  revealHiddenIfPossible();
  updateStripState();
  updateProgress();

  const cell = document.querySelector(`.cell[data-idx="${selectedCell}"]`);
  cell.classList.remove('selected');
  selectedCell = null;
  entryNums = [];
  entryOp = null;
  stripSelected = [];
  document.querySelectorAll('.strip-num').forEach(s => s.classList.remove('selected-strip'));
  updateControlsState();
  setStatus('', '');

  if (puzzle.userEntries.every(e => e !== null)) {
    setTimeout(() => checkAll(), 300);
  }
}

function renderStripState() {
  // Re-enable all non-hidden strip tiles first, then recompute usage state
  puzzle.strip.forEach((val, si) => {
    const el = document.querySelector(`.strip-num[data-idx="${si}"]`);
    if (!el) return;
    if (el.classList.contains('hidden-num') || el.classList.contains('hidden-revealed')) return;
    el.classList.remove('used', 'used-once');
    el.onclick = () => pickStripNum(si, val);
  });
  updateStripState();
}

function updateStripState() {
  // Count uses per strip index across all confirmed entries
  const usageCount = new Map(); // stripIdx â†’ count

  puzzle.userEntries.forEach(ue => {
    if (!ue) return;
    [ue.si1, ue.si2].forEach(si => {
      if (si !== undefined) usageCount.set(si, (usageCount.get(si) || 0) + 1);
    });
  });

  puzzle.strip.forEach((val, si) => {
    const el = document.querySelector(`.strip-num[data-idx="${si}"]`);
    if (!el || el.classList.contains('hidden-num')) return;
    const count = usageCount.get(si) || 0;
    if (count >= 2) {
      el.classList.add('used');
      el.classList.remove('used-once', 'selected-strip');
      el.style.removeProperty('opacity');
      el.style.removeProperty('pointer-events');
      el.onclick = () => { if (selectedCell === null) pulseHintCells(si); };
    } else if (count === 1) {
      el.classList.add('used-once');
      el.classList.remove('used');
    } else {
      el.classList.remove('used-once', 'used');
    }
  });
}

function revealHiddenIfPossible() {
  puzzle.hidden.forEach(i => {
    const isUsed = puzzle.userEntries.some(e => e && (e.si1 === i || e.si2 === i));
    if (isUsed) {
      const el = document.querySelector(`.strip-num[data-idx="${i}"]`);
      if (el && el.classList.contains('hidden-num')) {
        el.classList.remove('hidden-num');
        el.classList.add('hidden-revealed');
        el.textContent = puzzle.strip[i];
        el.onclick = () => {
          if (suppressNextClick) { suppressNextClick = false; return; }
          pickStripNum(i, puzzle.strip[i]);
        };
        addLongPress(el, () => clearHiddenTile(i));
      }
    }
  });
}

function checkAll() {
  if (!puzzle) return;
  let allFilled = true;
  let allCorrect = true;
  const errors = [];

  puzzle.userEntries.forEach((ue, i) => {
    const cell = document.querySelector(`.cell[data-idx="${i}"]`);
    cell.classList.remove('correct', 'wrong');
    if (!ue) { allFilled = false; return; }

    const { pair, op } = puzzle.grid[i];
    const pairMatch = (ue.a === pair.a && ue.b === pair.b) || (ue.a === pair.b && ue.b === pair.a);
    if (!pairMatch || ue.op !== op) {
      cell.classList.add('wrong');
      allCorrect = false;
      errors.push(i);
    } else {
      cell.classList.add('correct');
    }
  });

  if (!allFilled) {
    setTimeout(() => clearCellHighlights(), 3000);
    return;
  }

  if (allCorrect) {
    setStatus('Puzzle solved! ðŸŽ‰', 'success');
    setTimeout(() => {
      document.getElementById('winSub').textContent = `You solved the ${difficulty} puzzle!`;
      document.getElementById('winOverlay').classList.add('show');
    }, 400);
  } else {
    setStatus(`${errors.length} cell(s) incorrect.`, 'error');
    statusTimeout = setTimeout(() => { setStatus('', ''); clearCellHighlights(); }, 3000);
  }
}

function showSolution() {
  if (!puzzle) return;
  document.getElementById('checkBtn').disabled = true;
  puzzle.grid.forEach((cell, i) => {
    const si1 = puzzle.strip.indexOf(cell.pair.a);
    const si2 = puzzle.strip.indexOf(cell.pair.b);
    puzzle.userEntries[i] = { a: cell.pair.a, b: cell.pair.b, op: cell.op, si1, si2 };
    updateCellEntry(i);
    const el = document.querySelector(`.cell[data-idx="${i}"]`);
    el.classList.remove('wrong');
    el.classList.add('correct');
  });
  // Reveal all hidden
  puzzle.hidden.forEach(i => {
    const el = document.querySelector(`.strip-num[data-idx="${i}"]`);
    if (el) {
      el.classList.remove('hidden-num');
      el.classList.add('hidden-revealed');
      el.textContent = puzzle.strip[i];
    }
  });
  updateStripState();
  setStatus('Solution revealed.', 'info');
}

function confirmReveal() {
  document.getElementById('revealModal').classList.remove('show');
  showSolution();
}

function updateProgress() {
  const filled = puzzle ? puzzle.userEntries.filter(e => e !== null).length : 0;
  document.getElementById('progressCount').textContent = `${filled} / 16`;
}

// â”€â”€ Hidden number modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let hiddenModalSourceIdx = null;
let suppressNextClick = false;

function addLongPress(el, callback) {
  let timer = null, startX, startY;
  el.addEventListener('pointerdown', e => {
    startX = e.clientX; startY = e.clientY;
    timer = setTimeout(() => { timer = null; suppressNextClick = true; callback(); }, 500);
  });
  const cancel = () => { clearTimeout(timer); timer = null; };
  el.addEventListener('pointerup', cancel);
  el.addEventListener('pointercancel', cancel);
  el.addEventListener('pointermove', e => {
    if (timer && (Math.abs(e.clientX - startX) > 8 || Math.abs(e.clientY - startY) > 8)) cancel();
  });
  el.addEventListener('contextmenu', e => e.preventDefault());
}

function openHiddenModal(i) {
  hiddenModalSourceIdx = i;
  document.getElementById('hiddenInput').value = '';
  document.getElementById('hiddenModal').classList.add('show');
  setTimeout(() => document.getElementById('hiddenInput').focus(), 50);
}

function clearHiddenTile(i) {
  // Clear cells that used this strip tile
  let clearedSelected = false;
  puzzle.userEntries.forEach((ue, ci) => {
    if (!ue || (ue.si1 !== i && ue.si2 !== i)) return;
    if (ci === selectedCell) clearedSelected = true;
    puzzle.userEntries[ci] = null;
    puzzle.partialEntries[ci] = null;
    document.querySelector(`.cell[data-idx="${ci}"]`)?.classList.remove('correct', 'wrong');
    updateCellEntry(ci);
  });
  if (clearedSelected) {
    entryNums = [];
    entryOp = null;
    stripSelected = [];
    document.querySelectorAll('.strip-num').forEach(s => s.classList.remove('selected-strip'));
  }

  // Replace element with a fresh clone to shed all event listeners
  const el = document.querySelector(`.strip-num[data-idx="${i}"]`);
  if (el) {
    const fresh = el.cloneNode(false);
    fresh.className = 'strip-num hidden-num';
    fresh.textContent = '';
    fresh.onclick = () => openHiddenModal(i);
    el.parentNode.replaceChild(fresh, el);
  }

  renderStripState();
  updateProgress();
}

function closeHiddenModal() {
  hiddenModalSourceIdx = null;
  document.getElementById('hiddenModal').classList.remove('show');
}

function confirmHidden() {
  const val = parseInt(document.getElementById('hiddenInput').value, 10);
  if (isNaN(val) || val < 1) return;

  const i = hiddenModalSourceIdx;
  const el = document.querySelector(`.strip-num[data-idx="${i}"]`);
  if (el) {
    el.classList.remove('hidden-num');
    el.classList.add('hidden-revealed');
    el.textContent = val;
    el.onclick = () => {
      if (suppressNextClick) { suppressNextClick = false; return; }
      pickStripNum(i, val);
    };
    addLongPress(el, () => clearHiddenTile(i));
    renderStripState();
    updateProgress();
    if (selectedCell !== null) pickStripNum(i, val);
  }
  closeHiddenModal();
}

document.addEventListener('keydown', e => {
  if (document.getElementById('newGameModal').classList.contains('show')) {
    if (e.key === 'Escape') closeNewGameModal();
    return;
  }
  if (document.getElementById('revealModal').classList.contains('show')) {
    if (e.key === 'Escape') document.getElementById('revealModal').classList.remove('show');
    return;
  }
  if (!document.getElementById('hiddenModal').classList.contains('show')) return;
  if (e.key === 'Enter') confirmHidden();
  if (e.key === 'Escape') closeHiddenModal();
});

function clearCellHighlights() {
  document.querySelectorAll('.cell').forEach(c => c.classList.remove('correct', 'wrong'));
}

function setStatus(msg, type) {
  clearTimeout(statusTimeout);
  statusTimeout = null;
  const bar = document.getElementById('statusBar');
  bar.textContent = msg;
  bar.className = 'status-bar ' + (type || 'empty');
}

// Init op buttons
// Generate first puzzle
// Close how-to modal on outside click is handled inline on the modal element
generatePuzzle();
</script>
</body>
</html>
